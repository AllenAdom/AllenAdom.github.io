<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用谷歌云建站过程</title>
      <link href="/2020/04/19/shi-yong-gu-ge-yun-jian-zhan-guo-cheng/"/>
      <url>/2020/04/19/shi-yong-gu-ge-yun-jian-zhan-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="在Google-Cloud上申请VPS"><a href="#在Google-Cloud上申请VPS" class="headerlink" title="在Google Cloud上申请VPS"></a>在Google Cloud上申请VPS</h3><h4 id="注册谷歌云账号"><a href="#注册谷歌云账号" class="headerlink" title="注册谷歌云账号"></a>注册谷歌云账号</h4><p>想免费使用一年就必须要有一张<strong>信用卡</strong></p><ol><li><p>创建VPS</p><ul><li>在创建的时候可以参考我的配置，经查阅资料以下配置较优：</li></ul><img src="截屏2020-04-1918.31.07.png" alt="机型选择" style="zoom: 33%;"><ul><li>后勾选 <em>允许 HTTP 流量<em>、</em>允许 HTTPS 流量</em> 两个选项创建即可。</li></ul></li><li><p>配置VPS</p><ul><li><p>IP配置</p><p>实际上就是申请一个固定IP，可参考知乎上一篇<a href="https://zhuanlan.zhihu.com/p/60993816" target="_blank" rel="noopener">文章</a>，值得注意的是，其中有个一<strong>Attached to</strong>选项，你要选择你申请的IP绑定到你刚才创建的主机上。</p></li></ul></li></ol><h3 id="VPS-Linux安全配置"><a href="#VPS-Linux安全配置" class="headerlink" title="VPS-Linux安全配置"></a>VPS-Linux安全配置</h3><p>创建完VPS之后，谷歌提供了SSH登录的方式，回到VPS管理界面，可以看到有“连接”一列，提供了SSH方式，点击即可打开ssh登录页面。</p><p>登录之后进入系统的用户是谷歌自动给你创建的用户，出于安全性和便捷性，建议使用该用户作为以后的登录用户。</p><h4 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h4><pre class="line-numbers language-shell"><code class="language-shell"># 切换到root用户；无需密码sudo -i# 修改root密码passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="赋予普通用户超级权限"><a href="#赋予普通用户超级权限" class="headerlink" title="赋予普通用户超级权限"></a>赋予普通用户超级权限</h4><pre class="line-numbers language-shell"><code class="language-shell"># 在root下执行以下命令; 假设你的用户名为 xxxx# 添加xxxx刀超级用户组sudo usermod -a -G wheel xxxx# 设置xxxx密码passwd xxxx# 修改sudoers文件vi /etc/sudoers# 找到下面的部分root ALL=(ALL) ALL# 添加一行xxxx ALL=(ALL) ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置免密码登录"><a href="#配置免密码登录" class="headerlink" title="配置免密码登录"></a>配置免密码登录</h4><ol><li>本机生成公钥</li></ol><pre class="line-numbers language-shell"><code class="language-shell"># 在你的实体机上，执行以下命令；后接三个回车ssh-keygen -t rsa # 查看公钥cat ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>共享公钥<ul><li>将公钥字符串复制下来；</li><li>在VPS管理界面中找到 <em>元数据</em>   –&gt;  <em>SSH密钥</em>，可参考<a href="https://cloud.google.com/compute/docs/instances/adding-removing-ssh-keys?hl=zh_CN" target="_blank" rel="noopener">官方手册</a> 。</li></ul></li></ol><h4 id="修改SSH默认登录端口"><a href="#修改SSH默认登录端口" class="headerlink" title="修改SSH默认登录端口"></a>修改SSH默认登录端口</h4><ol><li>Linux端操作</li></ol><pre class="line-numbers language-shell"><code class="language-shell"># 在root模式下修改sshd_config文件vi /etc/ssh/sshd_config# 找到 #Port 22，将注释去掉，并在下一行添加； 记得保留22端口，以防修改失败！Port 666# 设置防火墙firewall-cmd --zone=public --add-port=666/tcp --permanentfirewall-cmd --reload# 查看是否设置成功firewall-cmd --permanent --query-port=10086/tcp# 设置SELinux，安装SELinux管理插件yum provides semanage# 查看ssh使用的端口semanage port -l | grep ssh# 添加666端口到sshdemanage port -a -t ssh_port_t -p tcp 666# 重启sshd服务systemctl restart sshd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>在谷歌云上添加防火墙规则</p><p>新建一条防火墙规则后，需要改的只有下方红框标注的三处，改完，应用即可。</p><img src="截屏2020-04-1920.18.18.png" alt="防火墙规则配置" style="zoom:50%;"></li></ol><p><font color="gray">注1: scp协议使用的也是22端口，以后再用scp传文件时要注意端口修改成666；</font></p><p><font color="gray">注2: ssh使用的是tcp协议；</font></p><h3 id="VPS应用"><a href="#VPS应用" class="headerlink" title="VPS应用"></a>VPS应用</h3><h4 id="申请免费域名"><a href="#申请免费域名" class="headerlink" title="申请免费域名"></a>申请免费域名</h4><ol><li><p>不需要先注册！</p></li><li><p>在<a href="https://my.freenom.com/" target="_blank" rel="noopener">freenom</a>网站上直接搜索你想要的域名，比如hhhhhaaaaa，在搜索框输入”hhhhhaaaaa.tk”，若能用直接选择即可。</p></li><li><p>选择 <em>12 months</em> –&gt; <em>Continue</em></p><p><img src="%E6%88%AA%E5%B1%8F2020-04-1920.35.23.png" alt="申请域名"></p></li><li><p>红框处填写邮箱注册</p><img src="截屏2020-04-1920.37.02.png" alt="注册" style="zoom:50%;"><p>注意：不要使用代理；注册时候 <em>国家</em> 一栏可能没有 <em>中国</em> 一项，可暂时选择其他的，后续注册完成可以再修改。若使用了代理，但是和你注册时候填写的地址不一致，则无法申请域名！</p></li><li><p>剩余步骤可参考 <a href="https://www.jianshu.com/p/408aaf2c121e" target="_blank" rel="noopener">链接</a></p></li></ol><h4 id="安装JDK-8和Tomcat"><a href="#安装JDK-8和Tomcat" class="headerlink" title="安装JDK 8和Tomcat"></a>安装JDK 8和Tomcat</h4><ol><li><p>安装JDK 8</p><pre class="line-numbers language-shell"><code class="language-shell"># 安装openjdk，不足之处就是openjdk有点大，安装要1.1个G; 安装后在/usr/lib/jvm目录下sudo yum install java-1.8.0-openjdk* -y# 修改全局环境变量vi /etc/profile# 在尾部追加export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.xx86_64export PATH=$PATH:$JAVA_HOME/bin# 测试echo $JAVA_HOMEjps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装Tomcat</p></li></ol><pre class="line-numbers language-shell"><code class="language-shell"># 因为tomcat文件较小，可以先下载到自己的主机上，上传到VPS上。可以选择使用谷歌自带的ssh工具传输，也可以使用scp命令上传。# 也可以使用wget直接下载sudo yum install wget -ywget https://downloads.apache.org/tomcat/tomcat-8/v8.5.54/bin/apache-tomcat-8.5.54.tar.gz# 解压到/opt文件夹下sudo mv tomcat8.tar.gz /optsudo tar -zxvf tomcat8.tar.gz# 修改默认端口sudo vi tomcat8/conf/server.xml# 找到 <Connector port="8080" protocol=。。。 修改<Connector port="12345" protocol=。。。# 启动tomcat; 关闭是 shutdown.shsudo ./bin/startup.sh# 配置防火墙端口sudo firewall-cmd --zone=public --add-port=12345/tcp --permanentsudo firewall-cmd --reload# 查看端口是否开启sudo netstat -ntlp# 记得在谷歌云中像添加ssh防火墙规则的方法 添加一个为端口12345使用的防火墙规则。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="域名绑定与解析"><a href="#域名绑定与解析" class="headerlink" title="域名绑定与解析"></a>域名绑定与解析</h4><ol><li><p>绑定域名</p><img src="截屏2020-04-1922.57.52.png" alt="绑定域名" style="zoom: 33%;"></li><li><p>选择 <em>Management Tools</em> –&gt; <em>Nameservers</em>  –&gt;  <em>Use custom nameservers (enter below)</em></p><p>填写<a href="https://console.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a>的域名解析地址：F1G1NS1.DNSPOD.NET、F1G1NS2.DNSPOD.NET</p></li><li><p>注册DNSPod账号</p></li><li><p>配置DNS</p><ul><li>在首页选择 <em>DNS</em></li><li><em>添加域名</em>  –&gt; 输入你的域名</li></ul></li><li><p>等待几分钟到几小时不等</p></li><li><p>访问 hhhhhaaaaa.tk:12345</p><p>你就能看到tomcat的欢迎页面了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> VPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab使用技巧</title>
      <link href="/2020/04/03/matlab-shi-yong-ji-qiao/"/>
      <url>/2020/04/03/matlab-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<ol><li><p>如何定义自变量 <em>x</em> ？</p><blockquote><p><em>&gt;&gt; x = 1 : 1 : 100</em></p><p>表示 <em>x</em> 从1开始，以间隔为1增至100，共100个数，实则为1*100的矩阵</p></blockquote></li><li><p>如何输入 <em>x</em> 的 <em>x</em> 次方？</p><blockquote><p><em>&gt;&gt;   y = x.^x</em></p></blockquote></li><li><p>如何输入 <em>ln x</em> ?</p><blockquote><p><em>&gt;&gt; $ y = log(x) $</em></p></blockquote></li><li><p>如何输入 <em>log<sub>2</sub> x</em> ?</p><blockquote><p><em>&gt;&gt; $y = log2(x)$</em></p></blockquote></li><li><p>如何在一张图上绘制多个函数？</p><blockquote><p><em>&gt;&gt; plot (x, y, x, u, ‘-.’, x, v, ‘:’, x, w, ‘–’)</em></p><p>其中，<em>y, u, v, w</em> 均是 <em>x</em> 的函数；’-.’ 表示虚点线 ；’:’ 表示点线；’–’ 表示实线</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算框架应用相关论文总结</title>
      <link href="/2020/03/25/ji-suan-kuang-jia-ying-yong-xiang-guan-lun-wen-zong-jie/"/>
      <url>/2020/03/25/ji-suan-kuang-jia-ying-yong-xiang-guan-lun-wen-zong-jie/</url>
      
        <content type="html"><![CDATA[<h5 id="K-means-parallel-acceleration-for-sparse-data-dimensions-on-Flink"><a href="#K-means-parallel-acceleration-for-sparse-data-dimensions-on-Flink" class="headerlink" title="K-means parallel acceleration for sparse data dimensions on Flink"></a>K-means parallel acceleration for sparse data dimensions on Flink</h5><p>总的来说，本文是从数据并行角度对K-means算法进行加速。</p><p>本文首先对数据进行了压缩，去除0元素，保留非0元素；然后使用贪心算法对数据集进行划分，最后使用Lal2、New3和Movie review三个数据集在flink平台上，配置1个master，2个workers节点进行实验论证。</p><h5 id="Energy-Efficient-Data-Caching-Framework-for-Spark-in-Hybrid-DRAM-NVM-Memory-Architectures"><a href="#Energy-Efficient-Data-Caching-Framework-for-Spark-in-Hybrid-DRAM-NVM-Memory-Architectures" class="headerlink" title="Energy-Efficient Data Caching Framework for Spark in Hybrid DRAM/NVM Memory Architectures"></a>Energy-Efficient Data Caching Framework for Spark in Hybrid DRAM/NVM Memory Architectures</h5><p>本文提出一种数据缓存架构，来提高spark框架的内存利用率。</p><h5 id="A-Parallel-Crime-Activity-Clustering-Algorithm-based-on-Apache-Spark-Cloud-Computing-Platform"><a href="#A-Parallel-Crime-Activity-Clustering-Algorithm-based-on-Apache-Spark-Cloud-Computing-Platform" class="headerlink" title="A Parallel Crime Activity Clustering Algorithm based on Apache Spark Cloud Computing Platform"></a>A Parallel Crime Activity Clustering Algorithm based on Apache Spark Cloud Computing Platform</h5><p>本文提出Criminal Activity Clustering (CAC) algorithm，运行在spark上，用于检测犯罪活动聚集检测。</p><h5 id="A-Parallel-Implementation-of-an-XDraw-Viewshed-Algorithm-with-Spark"><a href="#A-Parallel-Implementation-of-an-XDraw-Viewshed-Algorithm-with-Spark" class="headerlink" title="A Parallel Implementation of an XDraw Viewshed Algorithm with Spark"></a>A Parallel Implementation of an XDraw Viewshed Algorithm with Spark</h5><p>本文用spark加速地理领域，高分辨率栅格DEM数据的处理。</p><h5 id="Statistical-Analysis-for-Detection-of-Sensitive-Data-using-Hadoop-Clusters"><a href="#Statistical-Analysis-for-Detection-of-Sensitive-Data-using-Hadoop-Clusters" class="headerlink" title="Statistical Analysis for Detection of Sensitive Data using Hadoop Clusters"></a>Statistical Analysis for Detection of Sensitive Data using Hadoop Clusters</h5><p>本文用Hadoop集群来检测敏感数据。</p>]]></content>
      
      
      <categories>
          
          <category> 论文记录 机器学习算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习算法 论文记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可扩展机器学习的并行与分布式优化算法综述</title>
      <link href="/2020/03/24/ke-kuo-zhan-ji-qi-xue-xi-de-bing-xing-yu-fen-bu-shi-you-hua-suan-fa-zong-shu/"/>
      <url>/2020/03/24/ke-kuo-zhan-ji-qi-xue-xi-de-bing-xing-yu-fen-bu-shi-you-hua-suan-fa-zong-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="《可扩展机器学习的并行与分布式优化算法综述》"><a href="#《可扩展机器学习的并行与分布式优化算法综述》" class="headerlink" title="《可扩展机器学习的并行与分布式优化算法综述》"></a><center>《可扩展机器学习的并行与分布式优化算法综述》</center></h2><p>论文出处，点击此<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFDLAST2018&filename=RJXB201801006&v=MDgwODJDVVI3cWZaT1JyRnl6a1VidkFOeWZUYkxHNEg5bk1ybzlGWW9SOGVYMUx1eFlTN0RoMVQzcVRyV00xRnI=" target="_blank" rel="noopener">链接</a>。</p><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>机器学习问题通常会转化为一个目标函数去求解，优化算法是求解目标函数中参数的重要工具。本文对<strong>梯度下降算法</strong>、<strong>二阶优化算法</strong>、<strong>邻近梯度算法</strong>、<strong>坐标下降算法</strong>和<strong>交替方向乘子算法</strong>这五类常见算法展开研究，每一类算法分别从<strong>单机并行</strong>和<strong>分布式并行</strong>来分析相关研究成果。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>假如用到优化算法的并行和分布式可以参考这篇文章。暂时可以不做详细分析。</p>]]></content>
      
      
      <categories>
          
          <category> 论文记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文记录 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 优化算法 </tag>
            
            <tag> 综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度神经网络并行化研究综述-解读</title>
      <link href="/2020/03/23/shen-du-shen-jing-wang-luo-bing-xing-hua-yan-jiu-zong-shu-jie-du/"/>
      <url>/2020/03/23/shen-du-shen-jing-wang-luo-bing-xing-hua-yan-jiu-zong-shu-jie-du/</url>
      
        <content type="html"><![CDATA[<h2 id="《深度神经网络并行化研究综述》"><a href="#《深度神经网络并行化研究综述》" class="headerlink" title="《深度神经网络并行化研究综述》"></a><center>《深度神经网络并行化研究综述》</center></h2><p>论文出处，点击此<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFDLAST2018&filename=JSJX201808011&uid=WEEvREcwSlJHSldRa1Fhb09pSnNvVXIyNnJIeC92dW9MQWFIUHJCckJVST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4ggI8Fm4gTkoUKaID8j8gFw!!&v=Mjk1NzdydkpMejdCZHJHNEg5bk1wNDlFWllSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVI3cWZaT1JzRnkvbFY=" target="_blank" rel="noopener">链接</a>。</p><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>该文首先介绍了深度神经网络发展背景和常用的计算模型，然后对<strong>多核处理器、众核处理器和异构计算设备</strong>分别从功耗、计算能力、并行算法的开发难度等角度进行对比分析，接着对<strong>并行编程框架</strong>分别从支持的编程语言和硬件设备、编程难度等角度进行阐述。 然后<strong>以AlexNet为例</strong>分析了深度神经网络模型并行和数据并行两种方法的实施过程。接下来，从支持硬件、并行接口、并行模式等角度比较了常用的<strong>深度神经网络开源软件</strong>，并且通过<strong>实验比较和分析</strong>了卷积神经网 络在多核CPU和GPU上的并行性能。最后，对并行深度神经网络的未来发展趋势和面临的挑战进行<strong>展望</strong> 。</p><h4 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h4><p>计算能力指标，一般使用<strong>FLOPS</strong> 即每秒执行的32位浮点(FP32) 运算次数。CPU 计算性能一般采用的指标为每秒十亿次浮点运算 （ Giga Floating Point Oprations Per Second，GFLOPS ）和每秒万亿次浮点运算（ Tera Floating Point Oprations Per Second）。</p><h5 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h5><p>随着频率墙、<a href="https://zhidao.baidu.com/question/1696234362620387388.html" target="_blank" rel="noopener">功耗墙</a>和<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%A2%99/445399?fr=aladdin" target="_blank" rel="noopener">存储墙</a>问题越来越突出，单核CPU很难继续通过提高 钟频率来提升性能， 因此具有多核结构的计算设备逐渐成为主流。多核结构指的是在同一个处理器上集成两个或两个以上的<strong>计算内核</strong>，不同计算内核之间相互独立，可以并行的执行指令。</p><h5 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h5><p>GPU是以大量线程并行执行面向高吞吐量的设计，具有高带宽、高并行性的特点，因此GPU适用于大量数据的并行计算。</p><h5 id="MIC架构-Intel-Many-Integrated-Core"><a href="#MIC架构-Intel-Many-Integrated-Core" class="headerlink" title="MIC架构 (Intel Many Integrated Core)"></a>MIC架构 (Intel Many Integrated Core)</h5><p>可直接参考<a href="https://www.cnblogs.com/qysqys/p/5184209.html" target="_blank" rel="noopener">链接</a>。</p><h5 id="ASIC-Application-Specific-Integrated-Circuit"><a href="#ASIC-Application-Specific-Integrated-Circuit" class="headerlink" title="ASIC (Application Specific Integrated Circuit)"></a>ASIC (Application Specific Integrated Circuit)</h5><p>是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路。 为了最大计算速度和最小化能量消耗，针对深度学习设计专用集成电路，并将其应用于大规模云计算数据中心和嵌入式计算设备成为热门研究方向。</p><h5 id="FPGA-Field－Programmable-Gate-Array"><a href="#FPGA-Field－Programmable-Gate-Array" class="headerlink" title="FPGA (Field－Programmable Gate Array)"></a>FPGA (Field－Programmable Gate Array)</h5><p>FPGA就是一个可以通过编程来改变内部结构的芯片，在本质上是一个硬件上的可编程的器件。对比ASIC来说，因为ASIC芯片只是针对某一项功能做的专用芯片，如果要完成其他的功能就还得做一个另外的专用ASIC芯片，这样就大大的增加时间成本和人力成本，因为一个芯片的生产周期较长而且验证也是相当复杂的。FPGA就是为了解决上面的问题而出现的。</p><p><img src="%E6%88%AA%E5%B1%8F2020-03-2322.26.29.png" alt="硬件架构对比分析"></p><h4 id="并行编程架构"><a href="#并行编程架构" class="headerlink" title="并行编程架构"></a>并行编程架构</h4><h5 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h5><p>运行在NVIDIA本公司GPU上的并行编程语言。</p><h5 id="OpenCL"><a href="#OpenCL" class="headerlink" title="OpenCL"></a>OpenCL</h5><p>是Khronos组织制定的异构计算统一编程标准。因此可以运行在多核CPU 、 GPU、DSP、FPGA以及异构加速处理单元上。</p><h5 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h5><p>是基于<strong>共享内存</strong>和<strong>多线程</strong>的并行编程模型，在使用时需要程序员在程序可用于并行的部分添加并行编译的关键字，运行环境依据关键字将计算任务映射到多线程上并行执行。</p><h5 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h5><p>是一种基于消息传递的并行程序编程框架。作为一个跨语言的通讯协议，MPI支持点对点和广播两种通讯方式。但是基于MPI 的并行程序通常在算法上有较大改动，编程难度较大， 并且容错性不足，如果一个进程出现问题导致整个 应用需要重新进行计算。</p><h4 id="深度神经网络的模型并行和数据并行"><a href="#深度神经网络的模型并行和数据并行" class="headerlink" title="深度神经网络的模型并行和数据并行"></a>深度神经网络的模型并行和数据并行</h4><h5 id="模型并行"><a href="#模型并行" class="headerlink" title="模型并行"></a>模型并行</h5><p>模型并行（图5（a））是指将网络模型分解到各个计算设备上， 依靠设备间的共同协作完成训练。多数情况下，模型并行带来的<strong>通信开销和同步开销</strong>超过数据并行，因此加速比也不及数据并行， 但是对于单个计算设备内存无 法 容纳的大 模型来 说，模型并行是一个很好的选择。</p><h5 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h5><p>数据并行（图5（b））是指对训练数据做切分，同时采用多个模型实例，对多个分片的数据并行训练，由参数服务器来完成参数交换。在训练过程中，多个训练过程相互独 立，模型的变化量 Δｗ 需要传输给参数服务器， 由参数服务器负责更新为最新的模型 <em>ｗ′＝ｗ － η  · Δｗ</em>,其中<em>η</em>为学习率，然后再将最新的模型<em>ｗ′</em> 分发给训练程序。</p><p><img src="%E6%88%AA%E5%B1%8F2020-03-2322.43.10.png" alt="模型并行和数据并行"></p><h5 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h5><p>在深度神经网络中，为了求解代价函数，需要使用优化算法。目前最常用的优化算法是梯度下降法。该算法的核心是最小化目标函数，在每次迭代中，对每个变量按照目标函数在该变量梯度的相反方向更新对应的参数值，其中，参数学习率决定了函数到达最小值的迭代次数。</p><p>随机梯度下降算法（SGD）由于 速度快、效果可靠等优点在深度神经网络算法中得到了普遍应用。目前主要有同步 SGD和异步SGD两种机制。． 同步SGD需要利用所有节点上的参数信息，而慢节点所带来的同步 等待使得数据并行时的加速比并不理想。SGD异步虽然单次训练速度快，但是其固有的随机性使得网 络在训练过程中达到相同收敛点耗费的时间更长，且在训练后期可能会出现震荡现象。针对两者，论文中提到了有学者提出了相应<strong>缓解</strong>方法。</p><h4 id="深度神经网络开源软件系统并行化方法"><a href="#深度神经网络开源软件系统并行化方法" class="headerlink" title="深度神经网络开源软件系统并行化方法"></a>深度神经网络开源软件系统并行化方法</h4><p>Caffe、TensorFlow、MXNet、CNTK、PTorch、Theano这些软件对深度神经网络并行时使用了一些 相 似 的方法，在CPU上都使用了高性能多线程库来对网络进行训练，GPU在上都支持cuDNN（对CNN做一些GPU矩阵计算的优化）来对网络进行加速。在分布式并行深度神经网络的实现上，使用了数据并行或模型并行。</p><p><strong>论文中</strong>对上述软件都做了简要分析。</p><p><img src="%E6%88%AA%E5%B1%8F2020-03-2323.03.29.png" alt="分析表"></p><h4 id="深度神经网络并行化研究现状"><a href="#深度神经网络并行化研究现状" class="headerlink" title="深度神经网络并行化研究现状"></a>深度神经网络并行化研究现状</h4><h5 id="GPU-1"><a href="#GPU-1" class="headerlink" title="GPU"></a>GPU</h5><p>使用GPU来加速深度神经网络算法的训练过 程，一 般是使用CUDA或OpenCL将算法移植在GPU上，通过数据并行或模型并行，或者采用两者相结合的方法并行加速。</p><h5 id="MIC"><a href="#MIC" class="headerlink" title="MIC"></a>MIC</h5><p>使用MIC对深度神经网络训练过程并行加速时，一般使用OpenMP并行编程语言。将算法中的循环部分通过OpenMP和向量化指令做多线程和SIMD并行。</p><h5 id="ASIC"><a href="#ASIC" class="headerlink" title="ASIC"></a>ASIC</h5><p>设计专用加速器时，一般是通过分析算法特性，为其设计相应的硬件电路，充分利用算法中可并行的部分，为其中相应的操作分配具体的计算元件，从而获得更高的加速效果。</p><h5 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h5><p>开发难度大。</p><h5 id="多节点并行化"><a href="#多节点并行化" class="headerlink" title="多节点并行化"></a>多节点并行化</h5><p>集群分布式工作。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>上述5个方面，论文中都有举例。值得注意的是使用4块GPU可能比使用单GPU只提高了2x的加速比。</p><h4 id="深度神经网络并行化的挑战和展望"><a href="#深度神经网络并行化的挑战和展望" class="headerlink" title="深度神经网络并行化的挑战和展望"></a>深度神经网络并行化的挑战和展望</h4><h5 id="基于OpenCL的并行深度神经网络算法的性能可移植性"><a href="#基于OpenCL的并行深度神经网络算法的性能可移植性" class="headerlink" title="基于OpenCL的并行深度神经网络算法的性能可移植性"></a>基于OpenCL的并行深度神经网络算法的性能可移植性</h5><h5 id="深度神经网络模型并行中任务的自动划分"><a href="#深度神经网络模型并行中任务的自动划分" class="headerlink" title="深度神经网络模型并行中任务的自动划分"></a>深度神经网络模型并行中任务的自动划分</h5><p>已有的研究成果表明深度神经网络模型并行化 主要针对已设计好的神经网络结构采用手工划分网 络并将其映射到不同的计算设备上，手工划分网络 由于对任务负载的运行时间估计不够精准容易导致 计算节点上的负载不均衡。</p><h5 id="深度神经网络数据并行面临挑战"><a href="#深度神经网络数据并行面临挑战" class="headerlink" title="深度神经网络数据并行面临挑战"></a>深度神经网络数据并行面临挑战</h5><p>对于深度神经网络数据并行未来发展的趋势， 可从两个方向出发：第一是从算法角度，设计收敛速度快通信代价低的分布式随机梯度下降算法；第二是解决集群中不同节点间的通信瓶颈问题。</p><ol><li><p>多节点之间参数更新方式的选择</p><p>在保证算法精度和收敛速 度的前提下，减少同步等待所带来的开销。</p></li><li><p>异构计算节点间通信瓶颈</p><p>减少通信代价和保证算法收敛性之间的平衡成为关键。</p></li></ol><h5 id="基于新形态计算机的深度神经网络加速研究"><a href="#基于新形态计算机的深度神经网络加速研究" class="headerlink" title="基于新形态计算机的深度神经网络加速研究"></a>基于新形态计算机的深度神经网络加速研究</h5><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>首先该文是综述，给我们科普了一些内容。其中我觉得有意思的点是<strong>压缩神经网络</strong> 和 <strong>使用规约树算法提高了参数交换的效率和可扩展性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 论文记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文记录 </tag>
            
            <tag> 综述 </tag>
            
            <tag> 深度神经网络 </tag>
            
            <tag> 并行化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DL中遇到的名词解释</title>
      <link href="/2020/03/02/dl-zhong-yu-dao-de-ming-ci-jie-shi/"/>
      <url>/2020/03/02/dl-zhong-yu-dao-de-ming-ci-jie-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="Let’s-start-！"><a href="#Let’s-start-！" class="headerlink" title="Let’s start ！"></a>Let’s start ！</h3><h5 id="先验分布"><a href="#先验分布" class="headerlink" title="* 先验分布"></a>* 先验分布</h5><p>   先验分布（prior distribution）一译“验前分布”“事前分布”。是概率分布的一种。与“后验分布”相对。与试验结果无关，或与随机抽样无关，反映在进行统计试验之前根据其他有关参数口的知识而得到的分布。</p><h5 id="参数-超参数"><a href="#参数-超参数" class="headerlink" title="* 参数 超参数"></a>* 参数 超参数</h5><p><img src="%E6%88%AA%E5%B1%8F2020-03-0221.01.39.png" alt="参数和超参数"></p><h5 id="如何理解向量空间"><a href="#如何理解向量空间" class="headerlink" title="* 如何理解向量空间"></a>* 如何理解向量空间</h5><p>  容纳运动是空间的本质特征，“空间”是容纳运动的一个对象集合，而变换则规定了对应空间的运动。所以说，向量空间也是一个集合，这个集合对向量的加法和数乘是封闭的，也就是说，只要向量在这个空间内，那么向量按照加法和数乘的方式运动，就会一直在这个空间里。所以，对加法和数乘运算封闭的向量空间也称为线性空间。</p><h5 id="在GAN网络中，潜在空间-latent-space"><a href="#在GAN网络中，潜在空间-latent-space" class="headerlink" title="* 在GAN网络中，潜在空间 (latent space)"></a>* 在GAN网络中，潜在空间 (latent space)</h5><p><img src="%E6%88%AA%E5%B1%8F2020-03-0221.22.26.png" alt="lanten space"></p><h5 id="BatchNorm"><a href="#BatchNorm" class="headerlink" title="* BatchNorm"></a>* BatchNorm</h5><p>  我们都知道，深度学习的话尤其是在CV上都需要对数据做归一化，因为深度神经网络主要就是为了学习训练数据的分布，并在测试集上达到很好的泛化效果，但是，如果我们每一个batch输入的数据都具有不同的分布，显然会给网络的训练带来困难。另一方面，数据经过一层层网络计算后，其数据分布也在发生着变化，此现象称为<em>Internal Covariate Shift</em>，接下来会详细解释，会给下一层的网络学习带来困难。<em>batch norm</em>直译过来就是批规范化，就是为了解决这个分布变化问题。</p><p>详情可参考<a href="https://blog.csdn.net/qq_25737169/article/details/79048516" target="_blank" rel="noopener">batchnorm原理及代码详解</a></p><h5 id="正交规范化-（orthogonal-regulatization）"><a href="#正交规范化-（orthogonal-regulatization）" class="headerlink" title="* 正交规范化 （orthogonal regulatization）"></a>* 正交规范化 （orthogonal regulatization）</h5><p>正交阵的一个条件是：<em>W<sup>T</sup>W=I</em>  其中，<em>W</em>就是正交阵，<em>I</em>是单位阵。</p><p>正交阵的好处是，<strong>如果一个矩阵与一个正交阵相乘，这个矩阵的范数不会变化</strong>。保证范数就可以缓解梯度消失和爆炸。<a href="https://blog.csdn.net/qq_27261889/article/details/86608525" target="_blank" rel="noopener">参考</a></p><h5 id="谱归一化-（Spectral-Normalization）"><a href="#谱归一化-（Spectral-Normalization）" class="headerlink" title="* 谱归一化 （Spectral Normalization）"></a>* 谱归一化 （Spectral Normalization）</h5><p>  在GAN中，<strong>判别器训练越好，生成器梯度消失越严重。</strong>Spectral Norm使用一种更优雅的方式使得判别器 <em>D</em> 满足利普希茨连续性，限制了函数变化的剧烈程度，从而使模型更稳定。<a href="https://blog.csdn.net/StreamRock/article/details/83590347" target="_blank" rel="noopener">参考</a></p><h5 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="* 训练误差和泛化误差"></a>* 训练误差和泛化误差</h5><p>机器学习在训练数据集上表现出的误差叫训练误差；在任意测试数据集上表现出来的<strong>误差的期望值</strong>叫做泛化误差。</p><h5 id="欠拟合和过拟合"><a href="#欠拟合和过拟合" class="headerlink" title="* 欠拟合和过拟合"></a>* 欠拟合和过拟合</h5><p><img src="%E6%88%AA%E5%B1%8F2020-03-1010.36.55.png" alt="欠拟合和过拟合"></p><h5 id="Softmax"><a href="#Softmax" class="headerlink" title="* Softmax"></a>* Softmax</h5><p>我们知道max，假如说我有两个数，a和b，并且a&gt;b，如果取max，那么就直接取a，没有第二种可能。但有的时候我不想这样，因为这样会造成分值小的那个饥饿。所以我希望分值大的那一项经常取到，分值小的那一项也偶尔可以取到，那么我用softmax就可以了。</p><p> 现在还是a和b，a&gt;b，如果我们取按照softmax来计算取a和b的概率，那a的softmax值大于b的，所以a会经常取到，而b也会偶尔取到，概率跟它们本来的大小有关。所以说不是max，而是*<em>Soft *</em>max。</p><p><em>SVM只选自己喜欢的男神，Softmax把所有备胎全部拉出来评分，最后还归一化一下</em></p><h5 id="激活函数"><a href="#激活函数" class="headerlink" title="* 激活函数"></a>* 激活函数</h5><ol><li><p>什么是激活函数</p><p>首先要了解神经网络的基本模型。单一神经元模型如下图所示：</p><p><img src="20170107175151314.jpeg" alt="神经元"></p><p>神经网络中的每个神经元节点接受上一层神经元的输出值作为本神经元的输入值，并将输入值传递给下一层，输入层神经元节点会将输入属性值直接传递给下一层（隐层或输出层）。在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数（又称激励函数）。</p></li><li><p>激活函数的用途（为什么需要激活函数）？</p><p>如果不用激励函数（其实相当于激励函数是f（x）= x），在这种情况下你每一层节点的输入都是上层输出的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当，这种情况就是最原始的感知机（Perceptron）了，那么网络的逼近能力就相当有限。正因为上面的原因，我们决定引入非线性函数作为激励函数，这样深层神经网络表达能力就更加强大（不再是输入的线性组合，而是几乎可以逼近任意函数）。</p></li><li><p>常见激活函数</p><p><a href="https://baike.baidu.com/item/Sigmoid%E5%87%BD%E6%95%B0/7981407?fr=aladdin" target="_blank" rel="noopener">Sigmoid</a>函数、tanh函数、<a href="https://blog.csdn.net/qq_23304241/article/details/80300149" target="_blank" rel="noopener">Relu函数及其改进型</a>（如Leaky-ReLU、P-ReLU、R-ReLU等）在多层神经网络中应用比较多。</p></li></ol><h5 id="目标函数、损失函数、代价函数"><a href="#目标函数、损失函数、代价函数" class="headerlink" title="* 目标函数、损失函数、代价函数"></a>* 目标函数、损失函数、代价函数</h5><p>损失函数（loss function）和代价函数（cost function）是同一个东西，目标函数是一个与他们相关但更广的概念，对于目标函数来说在有约束条件下的最小化就是损失函数。</p><h5 id="正则化和正则化率"><a href="#正则化和正则化率" class="headerlink" title="* 正则化和正则化率"></a>* 正则化和正则化率</h5><p><img src="%E6%88%AA%E5%B1%8F2020-03-1012.26.09.png" alt="正则化和正则化率"></p><p><img src="%E6%88%AA%E5%B1%8F2020-03-1012.32.08.png" alt="L1和L2"></p><h5 id="什么是dropout"><a href="#什么是dropout" class="headerlink" title="* 什么是dropout"></a>* 什么是dropout</h5><p>dropout是指在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。注意是暂时，对于随机梯度下降来说，由于是随机丢弃，故而每一个mini-batch都在训练不同的网络。</p><h5 id="Boosting-Algorithm"><a href="#Boosting-Algorithm" class="headerlink" title="* Boosting Algorithm"></a>* Boosting Algorithm</h5><p>提升方法是基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断好。通俗点说，就是”三个臭皮匠顶个诸葛亮”。</p><p><a href="https://www.cnblogs.com/linyuanzhou/p/5019166.html" target="_blank" rel="noopener">可参考</a></p><h5 id="什么是梯度？"><a href="#什么是梯度？" class="headerlink" title="* 什么是梯度？"></a>* 什么是梯度？</h5><p>在介绍梯度之前我们要先回顾一下<strong>偏导数</strong>和<strong>方向导数</strong>的概念，因为梯度是基于这两个概念提出来的。</p><h6 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h6><p>一个多变量的函数的偏导数是它关于其中一个变量的导数，而保持其他变量恒定。例如： <em>f<sub>x</sub>(x, y)</em> 指的是函数在y方向不变，函数值沿着x轴方向的导数。</p><h6 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h6><p>但是偏导数有一个缺点，就是只能表示多元函数沿坐标轴方向的变化率，但是很多时候要考虑多元函数沿任意方向的变化率，于是就有了方向导数。</p><p>某个方向的导数，本质就是函数在A点上该方向切线的斜率；每个切线都代表一个方向，每个方向都是有方向导数的。</p><h6 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h6><p>梯度是针对某一点P的梯度，是一个向量<em>A</em>，它表示在点P的<em>A</em>方向上的函数变化最快，方向导数最大。当我们找到了这个向量<em>A</em>，就说是该点P的梯度。梯度是方向导数中的<strong>最大值</strong>，梯度一定是函数上升的方向， 最小值为0。</p><p>梯度下降法就是沿着梯度下降的方向求解极小值，梯度上升法沿就是着梯度上升的方向可以求得最大值。</p><p>什么叫梯度下降的方向？因为梯度本身有方向，所以梯度方向的负方向就是梯度下降的方向。同理，梯度上升的方向。</p><p>可<a href="https://www.cnblogs.com/ybjourney/p/12508027.html" target="_blank" rel="noopener">参考1</a>，<a href="https://zhuanlan.zhihu.com/p/24913912" target="_blank" rel="noopener">参考2</a>。</p><h5 id="池化层"><a href="#池化层" class="headerlink" title="* 池化层"></a>* 池化层</h5><p>池化层主要的作用：<br>（1）首要作用，<strong>下采样</strong>（downsamping）</p><iframe height="300" width="300" src="pooling_layer.mp4"></iframe><p>（2）降维、去除冗余信息、对特征进行压缩、简化网络复杂度、减小计算量、减小内存消耗等等。各种说辞吧，总的理解就是减少参数量。</p><p>（3）实现非线性（这个可以想一下，relu函数，是不是有点类似的感觉？）。</p><p>（4）可以扩大感知野。</p><p>（5）可以实现不变性，其中不变形性包括，平移不变性、旋转不变性和尺度不变性。</p><h5 id="CNN中卷积层计算细节"><a href="#CNN中卷积层计算细节" class="headerlink" title="* CNN中卷积层计算细节"></a>* CNN中卷积层计算细节</h5><p>参考 知乎<a href="https://zhuanlan.zhihu.com/p/29119239" target="_blank" rel="noopener">Michael Yuan</a></p><h6 id="卷积层尺寸的计算原理"><a href="#卷积层尺寸的计算原理" class="headerlink" title="卷积层尺寸的计算原理"></a>卷积层尺寸的计算原理</h6><ul><li><p><strong>输入矩阵</strong>格式：四个维度，依次为：样本数、图像高度、图像宽度、图像通道数</p></li><li><p><strong>输出矩阵</strong>格式：与输出矩阵的维度顺序和含义相同，但是后三个维度（图像高度、图像宽度、图像通道数）的尺寸发生变化。</p></li><li><p><strong>权重矩阵</strong>（卷积核）格式：同样是四个维度，但维度的含义与上面两者都不同，为：卷积核高度、卷积核宽度、输入通道数、输出通道数（等于卷积核个数）</p></li><li><p><strong>输入矩阵、权重矩阵、输出矩阵这三者之间的相互决定关系</strong></p><ul><li><p><strong>卷积核的输入通道数</strong>（in depth）由<strong>输入矩阵的通道数</strong>所决定。（红色标注）</p></li><li><p><strong>输出矩阵的通道数</strong>（out depth）由<strong>卷积核的输出通道数</strong>所决定。（绿色标注）</p></li><li><p><strong>输出矩阵的高度和宽度</strong>（height, width）这两个维度的尺寸由输入矩阵、卷积核、扫描方式所共同决定。计算公式如下。（蓝色标注)</p><p><img src="equation-5053801.svg" alt="输出矩阵的高度和宽度计算公式"></p><p><font color="gray">* 注：以下计算演示均省略掉了 Bias ，严格来说其实每个卷积核都还有一个 Bias 参数。</font></p></li></ul></li></ul><h6 id="标准卷积计算举例"><a href="#标准卷积计算举例" class="headerlink" title="标准卷积计算举例"></a>标准卷积计算举例</h6><blockquote><p>以 AlexNet 模型的第一个卷积层为例，<br>- 输入图片的尺寸统一为 227 x 227 x 3 （高度 x 宽度 x 颜色通道数），<br>- 本层一共具有96个卷积核，<br>- 每个卷积核的尺寸都是 11 x 11 x 3。<br>- 已知 stride = 4， padding = 0，<br>- 假设 batch_size = 256，<br>- 则输出矩阵的高度/宽度为 (227 - 11) / 4 + 1 = 55</p></blockquote><p><img src="equation-1.svg" alt="标准卷积计算举例"></p><h5 id="heuristic-based-method"><a href="#heuristic-based-method" class="headerlink" title="* heuristic-based method"></a>* heuristic-based method</h5><p>什么叫启发式的方法，就是经验论，根据经验规则进行发现的方法。</p><h5 id="集成学习-Ensemble-learing"><a href="#集成学习-Ensemble-learing" class="headerlink" title="* 集成学习(Ensemble learing)"></a>* 集成学习(Ensemble learing)</h5><p>集成学习算法是机器学习的一种新的学 习思想，该学习算法把同一个问题分解到多个不同的模块中，由多个学习器一起参与 学习，共同解决目标问题，从而提高分类器的泛化能力。</p><h5 id="非平衡数据"><a href="#非平衡数据" class="headerlink" title="* 非平衡数据"></a>* 非平衡数据</h5><p>非平衡数据是指数据集中某一类的<strong>样本数量明显少于其他类样本</strong>的数目，其中占 数量最多的一类样本被称为多数类，而占数量最少的一类则称为少数类。</p><h5 id="正样本和负样本"><a href="#正样本和负样本" class="headerlink" title="* 正样本和负样本"></a>* 正样本和负样本</h5><p>一种解释：在二分类数据集中，多数类简称为正类，少数类简称为负类。</p><p>二种解释：一般性模型优化的定义无所谓严格区分正负样本。实际中，应该以目标为导向，如果你的目标是<strong>识别出位置错误</strong>的信息，那么你应该定义<strong>位置错误的样本</strong>是正样本，然后根据选好的数据集进行相应的优化。如果你的目标是为了<strong>识别出位置正确的样本</strong>，那你应该定义<strong>位置正确的样本</strong>是<strong>正样本</strong>。至于为什么要根据目标来定义正样本，因为你在优化损失函数的时候，是根据预测错误的正样本来进行优化的，如果你的目标定义错误的话，你的优化方向可能是反过来的，特别是对正负样本不平衡的数据集来说。</p><h5 id="Concept-Drift（概念漂移）"><a href="#Concept-Drift（概念漂移）" class="headerlink" title="* Concept Drift（概念漂移）"></a>* Concept Drift（概念漂移）</h5><p>concept drift在机器学习、时间序列以及模式识别领域的一种<strong>现象</strong>。如果是在机器学习领域中，这个概念指的就是一个模型要去预测的一个<strong>目标变量</strong>，概念漂移就是这个目标变量随着<strong>时间</strong>的推移发生改变。概念漂移在很多领域都具有很重要的意义，例如对金融衍生品价格预测、动态控制等。</p><p>目前有很多广泛存在的数据，像金融数据、交通数据等，这类数据不同于传统的static data（静态数据），而是作为一种数据量大、实时性强的data stream（流式数据）而存在。流式数据分为稳定的数据流和动态的数据流，稳定的数据流具有稳定独立同分布的特点，而动态数据流则是不独立同分布的，所以会产生概念漂移的现象。</p><h5 id="Frobenius-norm-Frobenius-范数"><a href="#Frobenius-norm-Frobenius-范数" class="headerlink" title="* Frobenius norm(Frobenius 范数)"></a>* Frobenius norm(Frobenius 范数)</h5><p>Frobenius 范数，简称F-范数，是一种矩阵范数，记为||·||<sub>F</sub>。</p><p>矩阵A的<em>Frobenius范数</em>定义为矩阵A各项元素的绝对值平方的总和，即 </p><p>$||A|| <em>F = \sqrt{\sum</em>{i=1}^{m} \sum_{j=1}^n|a_{ij}|^2}$</p><p>可用于 利用低秩矩阵来近似单一数据矩阵。<br>用数学表示就是去找一个秩为k的矩阵B，使得矩阵B与原始数据矩阵A的差的F范数尽可能地小。</p><p>即： $ B = arg \min \limits_{rank(B)=k}||A-B|| _F$</p><h5 id="多目标优化问题-Pareto-Optimality"><a href="#多目标优化问题-Pareto-Optimality" class="headerlink" title="* 多目标优化问题(Pareto Optimality)"></a>* 多目标优化问题(<em>Pareto</em> <em>Optimal</em>ity)</h5><p>多目标优化一般是在pareto意义下寻求最优，这时最优解是parato frontier，不是一个点，是一个集合，这个集合里面任何点A无法<strong>dominate</strong>这个集合里面其他点B。这里说的<strong>dominate</strong>是指A无法<strong>所有的指标</strong>都比B好，这也就是多目标优化最优解的定义。如果要进一步确定到底最优的一个点是什么？那说明你要求的并不是多目标优化，你还是想找一个单目标优化，那就把所有目标函数加权吧。</p><p>多目标的朴素含义是：一个人去买衣服，商场里一共有100件衣服，那自变量解集就是这100件衣服，你需要决策的是选择哪件衣服。你决策的依据是目标函数，假设这里有2个目标，目标1是衣服越便宜越好，目标2是衣服越好看越好。</p><p>当然，如果你能找到一件衣服又好看又便宜，并且任何其他衣服衣服都没有他好看也没有他便宜，那问题就简单了，你就选择这一件。但是，更多的时候，问题是<strong><em>衣服A好看但是贵，衣服B没A好看但是便宜！那到底A和B哪个更好？</em></strong>其实大家逛商店买东西最纠结的不就是在于此吗？而Parato这个人聪明之处就在于捕捉了这个问题的本质并从数学上进行刻画。</p><p>回到原问题，你最后可能选出来5件衣服，这5件两两之间都是上述的A与B的关系，但是对于剩下的95件，你总能找到这5件里面一件可以在价格和好看与否方面都战胜对方。因而，这5件就是最后的多目标规划的解。</p><h5 id="半正定矩阵"><a href="#半正定矩阵" class="headerlink" title="* 半正定矩阵"></a>* 半正定矩阵</h5><p>半正定矩阵是<a href="https://baike.baidu.com/item/正定矩阵/11030459" target="_blank" rel="noopener">正定矩阵</a>的推广。实对称矩阵<em>A</em>称为半正定的，如果二次型<em>X’AX</em>半正定，即对于任意不为0的实列向量<em>X</em>，都有<em>X’AX</em>≥<em>0</em>。其中X’为X的转置。</p><h5 id="矩阵英文"><a href="#矩阵英文" class="headerlink" title="* 矩阵英文"></a>* 矩阵英文</h5><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>identity matrix</td><td>单位矩阵</td></tr><tr><td>positive semi-definite matrix</td><td>半正定矩阵</td></tr><tr><td>diagonal matrix</td><td>对角矩阵</td></tr><tr><td>main diagonal</td><td>主对角线</td></tr><tr><td>projection-free</td><td>免投影</td></tr><tr><td>entity、element</td><td>元素</td></tr><tr><td>inner product; dot product; scalar product</td><td>内积<sup>[1]</sup></td></tr><tr><td>coefficient matrix</td><td>系数矩阵<sup>[2]</sup></td></tr><tr><td>dominant eigenvector</td><td>主特征向量<sup>[3]</sup></td></tr><tr><td>standard orthonormal basis</td><td>标准正交基<sup>[4]</sup></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>备注：</p><p>[1]: 即两向量对应位置元素相乘，再求和。</p><p>[2]: 将方程组的系数组成矩阵来计算方程的解。</p><p>[3]: 一个矩阵可以有多个特征值，在这些特征值中，模最大的那个特征值即主特征值（对于实数阵即绝对值最大的特征值），主特征值对应的特征向量称为主特征向量。</p><p>[4]: 在线性代数中，一个<a href="https://baike.baidu.com/item/内积空间" target="_blank" rel="noopener">内积空间</a>的<strong>正交基</strong>（orthogonal basis）是元素两两正交的基。称基中的元素为<strong>基向量</strong>。假若，一个正交基的基向量的模长都是单位长度1，则称这正交基为<strong>标准正交基</strong>（Orthonormal basis）。</p><h5 id="One-hot向量"><a href="#One-hot向量" class="headerlink" title="* One-hot向量"></a>* One-hot向量</h5><p>如果有多个特征，“性别”有两个特征，“尺码”：M、L、XL三个值，我们用“01”表示男性，M为“100”，L为“010”，XL为“001”，所以一个样本，【“男性”、“L”】 one-hot编码为[10 010]，一个样本也就是5维的向量，这就是one-hot形式。</p><h5 id="核函数和核矩阵"><a href="#核函数和核矩阵" class="headerlink" title="* 核函数和核矩阵"></a>* 核函数和核矩阵</h5><p>令<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math.svg" alt="math">表示输入数据<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-7044286.svg" alt="math">的数据空间, 被称为<strong>输入空间</strong> (input space). <img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-1.svg" alt="math-1">是一个映射, 令<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-2.svg" alt="math-2">表示<strong>特征空间</strong> (feature space).</p><ul><li>数据实例<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-5.svg" alt="math-5">可以任意对象, 如文本, 序列, 图像, 字符串等;</li><li>对于给定的数据实例<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-5-7044785.svg" alt="math-5">，<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-6.svg" alt="math-6">是一个向量, 被称为<strong>特征向量</strong>.</li></ul><p>定义<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-7.svg" alt="math-7">是<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-8-7044891.svg" alt="math-8">上的<strong>核函数</strong>为<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-9.svg" alt="math-9">上的内积运算，即：</p><p><img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-10.svg" alt="math-10"></p><p>令<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-3.svg" alt="math-3">为输入空间中包含 <em>n</em> 个对象的数据集，则将 <em>D</em> 中的点对间的核函数（亦称为相似度函数、或核）表示为一个<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-4.svg" alt="math-4">的<strong>核矩阵</strong>，定义为：</p><p><img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-11.svg" alt="math-11"></p><p>核方法避免了显式地将输入空间中的每个点<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-5-7044785.svg" alt="math-5">变换到特征空间中的映射点<img src="DL%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/math-6.svg" alt="math-6"> ，而是直接通过核矩阵来获取. 这样，所有的相关分析均可转移到对核矩阵的研究上来.当然, 核矩阵也可以看作对应 <em>n</em> 个输入点的完全图的带权邻接矩阵.</p><p>注：核矩阵总是半正定矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 名词解释 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flink安装</title>
      <link href="/2019/12/13/flink-an-zhuang/"/>
      <url>/2019/12/13/flink-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="Flink-Mac本机模式安装"><a href="#Flink-Mac本机模式安装" class="headerlink" title="Flink  Mac本机模式安装"></a>Flink  Mac本机模式安装</h3><h4 id="下载Flink"><a href="#下载Flink" class="headerlink" title="下载Flink"></a>下载Flink</h4><p>​    到<a href="https://flink.apache.org/downloads.html" target="_blank" rel="noopener">官网</a>上，选择自己适合的Scala版本的flink。比如我的Scala版本是2.11.10。</p><h4 id="解压运行"><a href="#解压运行" class="headerlink" title="解压运行"></a>解压运行</h4><ul><li><p>下载后解压到你想安装的目录下</p></li><li><p>配置系统环境变量：FLINK_HOME<img src="%E6%88%AA%E5%B1%8F2019-12-1315.28.10.png" alt="Flink环境变量配置"></p></li><li><p>进入<code>$FLINK_HOME/bin</code> 下，运行 <code>start-cluster.sh</code> 命令。</p></li><li><p>在浏览器登录<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a></p><p><img src="%E6%88%AA%E5%B1%8F2019-12-1316.12.39.png" alt="flink单机运行截图"></p></li></ul><h3 id="Flink-集群安装（standalone模式）"><a href="#Flink-集群安装（standalone模式）" class="headerlink" title="Flink 集群安装（standalone模式）"></a>Flink 集群安装（standalone模式）</h3><h4 id="下载Flink-1"><a href="#下载Flink-1" class="headerlink" title="下载Flink"></a>下载Flink</h4><p>​    到<a href="https://flink.apache.org/downloads.html" target="_blank" rel="noopener">官网</a>上，选择自己适合的Scala版本的flink。比如我的Scala版本是2.11.10。</p><h4 id="解压配置"><a href="#解压配置" class="headerlink" title="解压配置"></a>解压配置</h4><ul><li><p>下载后解压到你想安装的目录下</p></li><li><p>配置系统环境变量：FLINK_HOME<img src="%E6%88%AA%E5%B1%8F2019-12-1315.37.31.png" alt="截屏2019-12-1315.37.31"></p></li><li><p>配置Flink，在<code>$FLINK_HOME/conf</code>目录下，修改<code>flink-conf.yaml</code>文件</p><table><thead><tr><th align="center">配置名称</th><th>参数</th><th>备注</th></tr></thead><tbody><tr><td align="center">jobmanager.rpc.address</td><td>sgmaster1</td><td>集群的master地址</td></tr><tr><td align="center">taskmanager.heap.size</td><td>2048</td><td>以M为单位</td></tr><tr><td align="center">jobmanager.heap.size</td><td>2048</td><td>以M为单位</td></tr><tr><td align="center">parallelism.default</td><td>2</td><td>并行度</td></tr><tr><td align="center"></td><td></td><td></td></tr></tbody></table></li><li><p>修改<code>master</code>和<code>slaves</code>文件</p><ul><li><p>master</p><p>sgmaster1</p></li><li><p>slaves(注意以行分隔)</p><p>sgmaster2</p><p>sgslave1</p><p>sgslave2</p><p>sgslave3</p></li></ul></li><li><p>分发flink文件夹到各个机器上</p><p>可用scp实现，也可以自己写一个脚本，用来集群之间传输文件。</p></li><li><p>启动flink</p><p>进入<code>$FLINK_HOME/bin</code> 下，运行 <code>start-cluster.sh</code> 命令。</p></li><li><p>在浏览器登录<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
          <category> 大数据 </category>
          
          <category> HPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink学习</title>
      <link href="/2019/11/23/flink-xue-xi/"/>
      <url>/2019/11/23/flink-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="数据集类型-和-数据运算模型"><a href="#数据集类型-和-数据运算模型" class="headerlink" title="数据集类型 和 数据运算模型"></a>数据集类型 和 数据运算模型</h3><h4 id="数据集类型"><a href="#数据集类型" class="headerlink" title="数据集类型"></a>数据集类型</h4><ul><li>无穷数据集：无穷的持续集成的数据集合<ul><li>用户与客户端的实时交互数据</li><li>应用实时产生的日志</li><li>金融市场的实时交易记录</li></ul></li><li>有界数据集：有限不会改变的数据集合</li></ul><h4 id="数据运算模型"><a href="#数据运算模型" class="headerlink" title="数据运算模型"></a>数据运算模型</h4><ul><li>流式：只要数据一直在产生，计算就持续地进行</li><li>批处理：在预先定义的时间内运行计算，当完成时释放计算机资源</li></ul><p>Flink 它可以处理有界的数据集、也可以处理无界的数据集、它可以流式的处理数据、也可以批量的处理数据。</p><h3 id="What-is-Flink"><a href="#What-is-Flink" class="headerlink" title="What is Flink"></a>What is Flink</h3><p><img src="WI7lRD.jpg" alt="Flink介绍"></p><h3 id="Flink作业提交流程"><a href="#Flink作业提交流程" class="headerlink" title="Flink作业提交流程"></a>Flink作业提交流程</h3><p><img src="p92UrK.jpg" alt="Flink作业提交流程"></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven编译Idea运行Spark2-4-4</title>
      <link href="/2019/11/17/maven-bian-yi-idea-yun-xing-spark2-4-4/"/>
      <url>/2019/11/17/maven-bian-yi-idea-yun-xing-spark2-4-4/</url>
      
        <content type="html"><![CDATA[<p>本文介绍如何在Mac下使用Maven编译Spark源码，并在Idea上调试运行</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>####Maven</p><p>​    Maven的版本要保证不要太老，3.5.2就有点老了，使用<code>mvn -v</code>可查看maven版本。我自己是先更新了maven版本为3.5.4。所谓更新就是把原来的maven目录删除掉，用新下载的maven解压覆盖即可； 然后再修改相应的<strong>maven配置文件(${M2_HOME/conf/settings})</strong>和<strong>环境变量</strong>。我的maven安装位置为：<code>/usr/local/opt/maven-3.5.4</code>。</p><h4 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h4><p>​    我们已经说明使用Spark 2.4.4，这个版本的spark默认依赖2.11.12的Scala，你当然也可以在<code>{spark dir}/pom.xml/&lt;scala.version&gt;</code>文件修改成你自己的Scala版本，但是建议使用原配。</p><p>​    使用<code>scala -version</code>查看自己Scala版本，我的Scala安装在<code>/usr/local/opt/scala-2.11.12</code>， 值得一提的是Mac上可以配置环境变量的地方很多，我自己统一配置在了<code>~/.bash_profile</code>里面。</p><h4 id="Spark-2-4-4源码"><a href="#Spark-2-4-4源码" class="headerlink" title="Spark 2.4.4源码"></a>Spark 2.4.4源码</h4><p>​    可以到<a href="https://spark.apache.org/downloads.html" target="_blank" rel="noopener">官网</a>下载，如下图：</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1720.27.35.png" alt="Spark官网下载"></p><p>​    也可以到<a href="https://github.com/apache/spark/tags">GitHub</a>上下载，点击要下载的版本，跳转到下载页面，选择一个压缩文件下载即可。</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1720.33.20.png" alt="sparkGitHub下载"></p><p>​    下载下来之后解压到一个工程目录就好。</p><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>​    这个自己下载安装即可。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>​    最开始我是解压完直接导入了idea中编译，结果就是折腾了很长时间都不能运行，直到现在我也没有解决，最后才决定先试用maven编译试一试，然后在idea中运行。</p><p>​    使用maven编译很简单，在你解压的根目录下，命令行运行<code>mvn -T 4 -DskipTests clean package</code>, 接下来就是等待了，我用了15分钟。过程我提几点：</p><ul><li>很消耗CPU和内存资源，笔记本呼呼的吹</li><li>maven要下载依赖包，这依赖于网速</li><li>过程中会出现很多warnings，不用管</li></ul><h3 id="在Idea中运行"><a href="#在Idea中运行" class="headerlink" title="在Idea中运行"></a>在Idea中运行</h3><ol><li><p>使用Idea <code>open -&gt; 选择解压根目录下的pom.xml文件 -&gt; Open as Project</code>， 接下来等待idea扫描完整个项目。</p></li><li><p>使用 command + ; 打开Project Structure，找到<code>spark-examples_2.11</code>, 然后在右侧找到<code>Dependencies</code>， 检查一下Module SDK是不是你的Java版本，然后点击<code>+</code>， 选择<code>Jars or directories</code>, </p><p>  找到<code>{sparkdir}/spark/assembly/target/scala-2.11/jars/</code>，添加进去。</p></li><li><p>运行Spark示例程序</p><p>找到<code>spark2。4.4 -&gt; examples -&gt;src -&gt; main -&gt; java -&gt; org.apache.spark.examples -&gt;JavaSparkPi</code>, 右键运行即可。</p></li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac快捷键</title>
      <link href="/2019/11/17/mac-kuai-jie-jian/"/>
      <url>/2019/11/17/mac-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>在finder中返回上级目录</td><td>command + ⬆️</td></tr><tr><td>在finder中显示隐藏文件和文件夹</td><td>command + shift + .</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2019/11/15/bo-ke-da-jian/"/>
      <url>/2019/11/15/bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<p>此博客搭建主要借助了 @<a href="https://github.com/godweiyang">韦阳</a> @<a href="https://github.com/blinkfox">闪烁之狐</a>，在此由衷的感谢他们。</p><h3 id="第一步-GitHub方面的准备"><a href="#第一步-GitHub方面的准备" class="headerlink" title="第一步 GitHub方面的准备"></a>第一步 GitHub方面的准备</h3><ol><li><p>需要一个GitHub账号</p></li><li><p>新建一个项目，即Repositories</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1517.09.10.png" alt="新建一个GitHub项目"></p><p>注意两点：</p><ul><li>在填写项目名称的时候，xxxxx处替换为你自己的GitHub名，比如我的是AllenAdom，那我就应该填AllenAdom.github.io 。</li><li>要勾选上README这一项</li></ul><ol start="3"><li>配置GitHub的免密钥登录</li></ol><p>可参考<a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-9" target="_blank" rel="noopener">韦阳</a>博客的说明，在<strong>连接Github与本地</strong>这一节</p></li></ol><h3 id="搭建博客所需软件"><a href="#搭建博客所需软件" class="headerlink" title="搭建博客所需软件"></a>搭建博客所需软件</h3><ol><li><p>安装Node js</p><p>在nodejs<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>处找到自己的系统版本，不一定要最新的，稳定的就可以，下载安装，安装就是下一步下一步。在我自己本机上的安装位置为：</p><ul><li>Node.js v12.13.0 to /usr/local/bin/node</li><li>npm v6.12.0 to /usr/local/bin/npm</li></ul><p>​    npm是nodejs自带安装的。</p></li><li><p>安装hexo</p><p>​    选择一个你想存储你博客的目录，比如我的是<code>/Users/allen/Documents/blogs</code>，命令行切换到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，可无视。安装完后输入<code>hexo -v</code>验证是否安装成功。如下：</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1517.21.58.png" alt="hexo验证"></p><p>​    然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p></li></ol><h4 id="至此博客准备缓解期已经完成了，下一步就是我们博客内容的添加。"><a href="#至此博客准备缓解期已经完成了，下一步就是我们博客内容的添加。" class="headerlink" title="至此博客准备缓解期已经完成了，下一步就是我们博客内容的添加。"></a>至此博客准备缓解期已经完成了，下一步就是我们博客内容的添加。</h4><h3 id="博客内容添加"><a href="#博客内容添加" class="headerlink" title="博客内容添加"></a>博客内容添加</h3><p>​    要说明一点的是，此处指博客内容是指<strong>博客框架</strong>，类似网站框架，具体文章的添加需要下一节才讲。</p><ol><li><p>下载<a href="https://github.com/godweiyang/hexo-matery-modified">博客框架</a>，解压后你会发现，此目录和你自己准备博客的目录是相似的，接下来直接覆盖你的博客目录下的内容即可。</p><ol start="2"><li><p>修改部分文件配置，改成自己的博客信息（<strong>以下我们以自己博客目录为根目录，记 /</strong>）：</p><ul><li>根目录下的<code>_config.yml</code>（/config.yml）文件，找到<code># Site</code>和<code># Deployment</code>修改为自己的信息</li></ul><p><img src="%E6%88%AA%E5%B1%8F2019-11-2021.55.30.png" alt="#Site"></p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1518.45.47.png" alt="# Deployment"></p><ol start="3"><li><p>替换<code>/themes/matery/source</code>目录下的<strong>favicon.png</strong>和<strong>logo.png</strong>， 要注意的是你要注意这两个图片的大小和后缀名，比如我的favicon.png，是680x1080px，你的图片大小最好和我的一致，否则可能显示出来很奇怪。</p></li><li><p>修改/themes/matery/_config.yml文件</p></li></ol><ul><li>修改个人信息</li></ul><pre class="line-numbers language-shell"><code class="language-shell"># The configuration of the second button in the home banner,# including the display name of the button, the font awesome icon, and the hyperlink to the button.# 首页 banner 中的第二个按钮的配置，包括按钮的显示名称、font awesome图标和按钮的超链接.indexbtn:  enable: true  name: Github  icon: fa-github-alt  url: https://github.com/AllenAdom# The configurations of the second line of home banner# icon/button will not show up if you leave the corresponding socialLink empty# 首页 banner 中的第二行个人信息配置，留空即不启用socialLink:  qq: 1543625734  github: AllenAdom  weibo: AllenAdom  email: weipengchengcs@.foxmail.com  zhihu: allen-adom# profile in about page, including avatars, career, and personal introductions.# 在”关于”页面中配置个人信息，包括头像、职业和个人介绍.profile:  avatar: /medias/avatars/avatar.jpg  career: 湖南大学 | 计算机科学与技术 | HPC  introduction: 我是湖南大学计算机科学与技术专业2019级硕士研究生。研究方向是大数据技术与高性能计算。我们实验室是望麓实验室，欢迎大家报考！# the Gitalk config，default disabled# Gitalk 评论模块的配置，默认为不激活gitalk:  enable: true  owner: AllenAdom  repo: AllenAdom.github.io  oauth:    clientId:     clientSecret:   admin: AllenAdom# Whether to display fork me on github icon and link, default true, You can change it to your repo address# 配置是否在 header 中显示 fork me on github 的图标，默认为true，你可以修改为你的仓库地址.githubLink:  enable: true  url: https://github.com/godweiyang  title: Fork Me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>该文件还可以配置一些博客框架的功能，举一例：</li></ul><pre class="line-numbers language-shell"><code class="language-shell"># Whether to display the musics.# 是否在首页显示音乐.music:    # true为启用该功能，不想起用就用改为 false  enable: true  showTitle: false  title: 听听音乐  fixed: false # 开启吸底模式  autoplay: true # 是否自动播放  theme: '#542674'  loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'list' # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false # 列表默认折叠  listMaxHeight: #列表最大高度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>替换<code>/themes/matery/source/medias/avatars</code>下的<strong>avatar.jpg</strong></li></ol></li></ol></li><li><p>在<code>/source/_data</code>目录下有一个<strong>musics.json</strong>文件，这文件里面描述了<code>/themes/matery/source/medias/music</code>的信息，假如你在本节的第4步中启用了music这一功能，那你就需要下载好musics.json中所需要的文件，其实就是四个mp3文件，放到<code>/themes/matery/source/medias/music</code>目录下。</p><ol start="7"><li><p>修改<code>/themes/matery/layout/_partial/footer.ejs</code></p><p>这里我主要修改了建站时间；ejs文件用文本编辑器打开即可。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">language</span><span class="token attr-value"><span class="token punctuation">=</span>javascript</span><span class="token punctuation">></span></span><span class="token script language-javascript"> <span class="token keyword">function</span> <span class="token function">siteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"siteTime()"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> seconds <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> minutes <span class="token operator">=</span> seconds <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> hours <span class="token operator">=</span> minutes <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> days <span class="token operator">=</span> hours <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> years <span class="token operator">=</span> days <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> today <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> todayYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> todayMonth <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> todayDate <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> todayHour <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> todayMinute <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> todaySecond <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> t1 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">UTC</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 修改这个时间为你建站时间</span>     <span class="token keyword">var</span> t2 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">UTC</span><span class="token punctuation">(</span>todayYear<span class="token punctuation">,</span> todayMonth<span class="token punctuation">,</span> todayDate<span class="token punctuation">,</span> todayHour<span class="token punctuation">,</span> todayMinute<span class="token punctuation">,</span> todaySecond<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> diff <span class="token operator">=</span> t2 <span class="token operator">-</span> t1<span class="token punctuation">;</span>     <span class="token keyword">var</span> diffYears <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>diff <span class="token operator">/</span> years<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> diffDays <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">/</span> days<span class="token punctuation">)</span> <span class="token operator">-</span> diffYears <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> diffHours <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days<span class="token punctuation">)</span> <span class="token operator">/</span> hours<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> diffMinutes <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days <span class="token operator">-</span> diffHours <span class="token operator">*</span> hours<span class="token punctuation">)</span> <span class="token operator">/</span> minutes<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> diffSeconds <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days <span class="token operator">-</span> diffHours <span class="token operator">*</span> hours <span class="token operator">-</span> diffMinutes <span class="token operator">*</span> minutes<span class="token punctuation">)</span> <span class="token operator">/</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>     document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"sitetime"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"本站已运行 "</span> <span class="token operator">+</span> diffYears <span class="token operator">+</span> <span class="token string">" 年 "</span> <span class="token operator">+</span> diffDays <span class="token operator">+</span> <span class="token string">" 天 "</span> <span class="token operator">+</span> diffHours <span class="token operator">+</span> <span class="token string">" 小时 "</span> <span class="token operator">+</span> diffMinutes <span class="token operator">+</span> <span class="token string">" 分钟 "</span> <span class="token operator">+</span> diffSeconds <span class="token operator">+</span> <span class="token string">" 秒"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">siteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ol><h3 id="新建并发布博客"><a href="#新建并发布博客" class="headerlink" title="新建并发布博客"></a>新建并发布博客</h3><ol><li><p>新建博客</p><p>​    命令行切换到<code>/</code>目录下，运行<code>hexo new &quot;你的博客名字&quot;</code>， 这样你就发想在<code>/source/_posts</code>多了一个<code>你的博客名字.md</code>和<code>你的博客名字</code>的文件夹，这就是你刚才新建的博客了。</p><p>​    比如我新建了一个<code>test</code>的博客，打开并写入了“哈哈哈哈哈哈”在里面：</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1519.41.17-3819369.png" alt="test.md"></p></li><li><p>生成博客</p><p>命令行切换到<code>/</code>目录下，运行<code>hexo g</code>命令，生成html文档。</p></li><li><p>预览博客</p><p>命令行切换到<code>/</code>目录下，运行<code>hexo s</code>，在浏览器中输入<code>http://localhost:4000/</code>，滑到最底下你就可以看到你新建的博客了：</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1519.45.53.png" alt="test博客"></p></li><li><p>发布到GitHub上</p><p>​    命令行切换到<code>/</code>目录下，运行<code>hexo d</code>，就可以发布到GitHub上我们刚开始新建的项目了。在浏览器中输入<code>https://xxxx.github.io/</code>，<code>xxxx</code>就是你GitHub的名字，前面我们提到过。如下图所示：</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1519.54.55-3819098.png" alt="https://allenadom.github.io/"></p></li></ol><h4 id="至此我们已经有了自己的博客啦！！！！"><a href="#至此我们已经有了自己的博客啦！！！！" class="headerlink" title="至此我们已经有了自己的博客啦！！！！"></a>至此我们已经有了自己的博客啦！！！！</h4><h3 id="编辑博客"><a href="#编辑博客" class="headerlink" title="编辑博客"></a>编辑博客</h3><p>​    关于如何编辑我们的博客，我自己使用Typora编辑md文件的，这款软件漂亮、简洁，用起来很上手。关于如何用Typora编辑md文件，主要是一些方法和技巧在我的<a href="https://allenadom.github.io/2019/11/15/typora-shi-yong-ji-qiao/" target="_blank" rel="noopener">另外一篇博客</a>里面有介绍，并且一致随着使用保持更新，欢迎访问。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora使用技巧</title>
      <link href="/2019/11/15/typora-shi-yong-ji-qiao/"/>
      <url>/2019/11/15/typora-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Typora显示文本样式"><a href="#使用Typora显示文本样式" class="headerlink" title="使用Typora显示文本样式"></a>使用Typora显示文本样式</h1><ol><li><p>输出无序序列和有序序列</p><p>* <strong>+ *<em>空格或者 -  *</em>+</strong> 空格都可以输出无序序列</p><p>数字 <strong>+</strong> . <strong>+</strong> 空格，可以输出有序序列</p></li><li><p>使插入文本为斜体</p><p>单星号(*)开头单星号结尾， 双星号是加粗哦</p><p>注：快捷键是command + l</p></li><li><p>居中文本</p><p>加&lt;center&gt;要居中的文本&lt;/center&gt;标签即可哦。</p></li><li><p>转义字符 \</p></li><li><p>设置指定文本样式，可直接参考markdown语法。</p><p>例如改变文本颜色</p><p>&lt;font color=”gray” size=2&gt;文本&lt;/font&gt;或者&lt;font color=#0000FF &gt;文本&lt;/font&gt;</p></li><li><p>输入数学公式</p><p>可以参考<a href="https://blog.csdn.net/happyday_d/article/details/83715440" target="_blank" rel="noopener">Typora中利用LaTeX 插入数学公式</a>，很全面。</p><p>补充：</p><ul><li>集合”属于“符号：\in   更多集合符号可参考<a href="https://blog.csdn.net/weixin_36670529/article/details/99944700" target="_blank" rel="noopener">LaTex集合之间关系表示</a></li></ul></li></ol><h1 id="Typora快捷键-For-Mac"><a href="#Typora快捷键-For-Mac" class="headerlink" title="Typora快捷键(For Mac)"></a>Typora快捷键(For Mac)</h1><ol><li><p>Option + Command + T</p><p>插入表格，会弹出选择要生成表格的行数和列数，如下图：</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1516.29.26.png" alt="插入表格"></p></li><li><p>插入超链接</p><p>复制要添加的超链接， 在文件中选择要附加超链接的文本，然后command + k 就可以了。</p><p>比如<a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a>， 我要给前面“百度”两个字添加百度的网址，就要先复制百度网址，然后选中前面的百度两个字，按下快捷键就可以了。</p><p><img src="%E6%88%AA%E5%B1%8F2019-11-1520.21.31.png" alt="插入超链接"></p><p>可以看到那俩字更白了，还有下划线。</p></li><li><p>输入上标和下标</p><p><img src="%E6%88%AA%E5%B1%8F2019-12-3110.02.54.png" alt="上标和下标"></p></li><li><p>快速插入n级(n=1,2,3,4,5,6)标题</p><p>Command + n (n=1,2,3,4,5,6)</p></li><li><p>Typora实现公式中字母带有头顶符号的，如箭头，波浪线和角号等</p><p><img src="%E6%88%AA%E5%B1%8F2020-03-1610.15.56.png" alt="字母头顶带符号"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客之路的起始</title>
      <link href="/2019/11/15/bo-ke-zhi-lu-de-qi-shi/"/>
      <url>/2019/11/15/bo-ke-zhi-lu-de-qi-shi/</url>
      
        <content type="html"><![CDATA[<p>在计算机这个专业已经快五年了，一直没有自己的博客，这次想搭一个，谨以此纪念本人博客的开始。</p><h1 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h1><p>​    其实写博客的念头在几年前就有了，有好几次都是脑袋里冒出来这么个念头，但是因为懒，觉得麻烦，就那么多次地放弃了，但是这次下决心写，主要有以下几个方面：</p><ul><li><strong>记录自己一些软件的安装配置过程</strong>，方便以后参考</li><li>记录自己的一些经历和想法，留存一下</li><li>想自己去维护一个东西，比如博客，想坚持做一件事</li><li>为了以后工作，提供给面试官看，证明一下自己</li></ul><p>​    基于以上原因，所以想自己维护一个博客吧，做起来吧，相信不管什么坚持下来都会有收获，在此祝愿自己的博客越做越大，越做越好！</p><h1 id="我想做成一个什么样的博客"><a href="#我想做成一个什么样的博客" class="headerlink" title="我想做成一个什么样的博客"></a>我想做成一个什么样的博客</h1><p>​    凡事总要有个目标或者说要求，我想我的博客要满足一下几个要求：</p><ol><li>界面美观大方，能吸引人眼球。</li><li>内容类型偏向技术型，学术型，内容要有条理、清晰，表达力求精炼和完整。</li><li>记录想法和思考时，要有前因后果，不可无中生有。</li></ol><p>如果要用一句话描述上述需求的话，就是：界面美观、内容充实、表达完整。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    最后用一张图来表达一下希望我和大家能一直有的生活态度吧！</p><p><img src="%E5%93%88%E5%93%88.jpg" alt="你好哇！"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
